// Generated by CoffeeScript 1.8.0
var arg, argTab, buildAssetsFiles, count, default_port, del, dirpath, each, exec, fs, getNewPort, http, i, ini, init, initRepo, list, multimatch, parameters, params, path, rm, start, stop, sync, url, util, _dockerExec, _i, _len, _runRepo,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

parameters = require('parameters');

path = require('path');

rm = require('remove');

multimatch = require('multimatch');

exec = require('child_process').exec;

each = require('each');

url = require('url');

ini = require('my-node-ini');

http = require('request');

util = require('util');

dirpath = path.normalize("" + (path.dirname(process.argv[1])) + "/../shims");

default_port = 100180;

list = function(repos) {
  var dir, file, _i, _len, _results;
  if (repos != null) {
    dir = multimatch(fs.readdirSync(dirpath), repos);
  } else {
    dir = fs.readdirSync(dirpath);
  }
  _results = [];
  for (_i = 0, _len = dir.length; _i < _len; _i++) {
    file = dir[_i];
    _results.push(console.log(file));
  }
  return _results;
};

getNewPort = function() {
  var port, port_path;
  port_path = "" + dirpath + "/../port_inc.conf";
  if (fs.existsSync(port_path)) {
    port = parseInt(fs.readFileSync(port_path));
  } else {
    port = default_port;
  }
  fs.writeFileSync(port_path, "" + (port + 1));
  return port;
};

buildAssetsFiles = function(repo, u, config) {
  var buf, repopath, sync, url_name, url_path;
  url_path = url.parse(u).pathname;
  url_name = url_path.split('/');
  url_name = url_name[url_name.length - 1];
  repopath = "" + dirpath + "/" + repo;
  fs.mkdirSync("" + repopath + "/assets");
  buf = '#!/bin/bash\n';
  buf += 'set -e\n\n';
  buf += 'yum clean expire-cache\n';
  sync = buf;
  buf += "wget -nv " + u + " -O /etc/yum.repos.d/" + url_name + "\n";
  buf += 'yum update -y\n';
  sync += 'yum update -y\n';
  Object.keys(config).forEach(function(element, key, _array) {
    path = url.parse(config[element].baseurl).pathname;
    buf += "\n# [" + element + "]\n";
    sync += "\n# [" + element + "]\n";
    buf += "mkdir -p /var/www/html" + path + "\n";
    buf += "reposync -p /var/www/html" + path + " --repoid=" + element + "\n";
    sync += "reposync -p /var/www/html" + path + " --repoid=" + element + "\n";
    return buf += "createrepo /var/www/html" + path + "\n";
  });
  fs.writeFileSync("" + repopath + "/assets/init", buf);
  fs.chmodSync("" + repopath + "/assets/init", 0x1ed);
  fs.writeFileSync("" + repopath + "/assets/sync", sync);
  return fs.chmodSync("" + repopath + "/assets/sync", 0x1ed);
};

_runRepo = function(repo, init) {
  var app, port, repopath;
  repopath = "" + dirpath + "/" + repo;
  if (init) {
    port = getNewPort();
    fs.writeFileSync("" + repopath + "/port", port);
    app = 'init';
  } else {
    port = fs.readFileSync("" + repopath + "/port");
    app = 'sync';
  }
  return exec("docker run -v " + repopath + "/assets/:/app/ -v " + repopath + "/repo:/var/www/html/ --rm=true --entrypoint /app/" + app + " ryba_repos/syncer", function(r_err, r_stdout, r_stderr) {
    if (r_err) {
      return console.log(r_stderr);
    } else {
      return exec("docker run --name=repo_" + repo + " -d -v " + repopath + "/repo:/usr/local/apache2/htdocs/ -p " + port + ":80 httpd", function(err, stdout, stderr) {
        if (err) {
          return console.log(stderr);
        }
      });
    }
  });
};

initRepo = function(repo, u, proxy) {
  var repopath;
  repopath = "" + dirpath + "/" + repo;
  return fs.exists(repopath, function(exists) {
    var options;
    if (exists) {
      console.log("[" + repo + "] repo already exists, ignoring configuration step");
      return _runRepo(repo, false);
    } else {
      console.log("[" + repo + "] creating configuration files...");
      options = {
        url: u
      };
      if (proxy) {
        options.proxy = proxy;
      }
      return http(options, function(err, response, body) {
        var config;
        config = ini.parse(body);
        return fs.mkdir(repopath, function() {
          buildAssetsFiles(repo, u, config);
          return fs.mkdir("" + repopath + "/repo", function() {
            console.log("[" + repo + "] end of configuration files creation");
            return _runRepo(repo, true);
          });
        });
      });
    }
  });
};

sync = function(repos) {
  if (repos == null) {
    repos = fs.readdirSync(dirpath);
  }
  return each(repos).parallel(true).on('item', function(repo, next) {
    return _runRepo(repo, false);
  }).on('both', function(err) {
    if (err) {
      return console.log('Finished with ERRORS');
    } else {
      return console.log('Finished successfully!');
    }
  });
};

init = function(repos, urls, proxy) {
  if (repos.length !== (urls != null ? urls.length : void 0)) {
    console.log("targetted repos number (" + repos.length + ") and urls number (" + (urls != null ? urls.length : void 0) + ") don't match, exiting...");
    process.exit(22);
  }
  return each(repos).parallel(true).on('item', function(repo, index, next) {
    return initRepo(repo, urls != null ? urls[index] : void 0, proxy);
  }).on('both', function(err) {
    if (err) {
      return console.log('Finished with errors :', err.message);
    } else {
      return console.log('Finished successfully !');
    }
  });
};

_dockerExec = function(repos, action) {
  console.log("" + action + " " + repos + ":");
  return each(repos).parallel(true).on('item', function(repo, next) {
    return exec("docker " + action + " " + repo, function(err, stdout, stderr) {
      return console.log("[" + repo + "]: " + stderr);
    });
  }).on('both', function(err) {
    if (err) {
      return console.log('#{action} finished with errors');
    } else {
      return console.log('#{action} finished successfully !');
    }
  });
};

start = function(repos) {
  var i, repo, _i, _len;
  if (repos != null) {
    for (i = _i = 0, _len = repos.length; _i < _len; i = ++_i) {
      repo = repos[i];
      repos[i] = "repo_" + repo;
    }
    return _dockerExec(repos, 'start');
  } else {
    return exec("docker ps -a | grep -oh 'repo_\\S\\+'", function(err, stdout, stderr) {
      if (err) {
        return console.log("Impossible to list repo docker containers: " + stderr);
      } else {
        repos = stdout.split('\n');
        repos.pop();
        return _dockerExec(repos, 'start');
      }
    });
  }
};

stop = function(repos) {
  var i, repo, _i, _len;
  if (repos != null) {
    for (i = _i = 0, _len = repos.length; _i < _len; i = ++_i) {
      repo = repos[i];
      repos[i] = "repo_" + repo;
    }
    return _dockerExec(repos, 'stop');
  } else {
    return exec("docker ps | grep -oh 'repo_\\S\\+'", function(err, stdout, stderr) {
      if (err) {
        return console.log("Impossible to list running repo docker containers: " + stderr);
      } else {
        repos = stdout.split('\n');
        repos.pop();
        return _dockerExec(repos, 'stop');
      }
    });
  }
};

del = function(repos) {
  return each(repos).parallel(true).on('item', function(repo, next) {
    exec("docker rm repo_" + repo, function(err, stdout, stderr) {
      if (err != null) {
        return console.log("[" + repo + "] " + stderr);
      }
    });
    return rm.removeSync("" + dirpath + "/" + repo);
  }).on('both', function(b_err) {
    if (b_err) {
      return console.log("Finished with ERRORS");
    } else {
      return console.log('Finished successfully!');
    }
  });
};

params = parameters({
  name: 'repos',
  description: 'Install and sync RHEL/CentOS repositories',
  commands: [
    {
      name: 'list',
      description: 'list all the installed repositories',
      options: [
        {
          name: 'repo',
          type: 'array',
          shortcut: 'r',
          description: 'filter'
        }
      ]
    }, {
      name: 'init',
      description: 'initialize local repo with Docker container',
      options: [
        {
          name: 'repo',
          type: 'array',
          shortcut: 'r',
          required: true,
          description: 'repo(s) to initialize'
        }, {
          name: 'url',
          type: 'array',
          shortcut: 'u',
          required: true,
          description: 'the url(s) of the repo(s)'
        }, {
          name: 'proxy',
          shortcut: 'p',
          description: 'a proxy parameter if needed'
        }
      ]
    }, {
      name: 'start',
      description: 'Start Repo server(s) with Docker without synchronizing repo',
      options: [
        {
          name: 'repo',
          type: 'array',
          shortcut: 'r',
          description: 'the repo(s) to start. All by default'
        }
      ]
    }, {
      name: 'stop',
      description: 'Stop Repo server(s) with Docker',
      options: [
        {
          name: 'repo',
          type: 'array',
          shortcut: 'r',
          description: 'the repo(s) to stop. All by default'
        }
      ]
    }, {
      name: 'rm',
      description: 'Delete a repo',
      options: [
        {
          name: 'repo',
          shortcut: 'r',
          type: 'array',
          required: true,
          description: 'the repo to delete'
        }
      ]
    }
  ]
});

argTab = process.argv.slice(2, process.argv.length);

if (argTab.length > 1 && __indexOf.call(argTab, '-r') < 0) {
  count = 0;
  for (i = _i = 0, _len = argTab.length; _i < _len; i = ++_i) {
    arg = argTab[i];
    if ('-' === arg.charAt(0)) {
      count = 0;
    } else {
      count++;
      if (count === 2) {
        argTab.splice(i, 0, '-r');
        break;
      }
    }
  }
}

arg = params.parse(argTab);

if (arg.command === 'help') {
  console.log(params.help(arg.name));
}

switch (arg.command) {
  case 'list':
    list(arg.repo);
    break;
  case 'init':
    init(arg.repo, arg.url, arg.proxy);
    break;
  case 'sync':
    sync(arg.repo, arg.proxy);
    break;
  case 'start':
    start(arg.repo);
    break;
  case 'stop':
    stop(arg.repo);
    break;
  case 'rm':
    del(arg.repo);
}
