// Generated by CoffeeScript 1.9.1
var Repos, db, docker, each, fs, http, ini, multimatch, path, rmr, url, utils,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

path = require('path');

rmr = require('remove');

multimatch = require('multimatch');

each = require('each');

url = require('url');

ini = require('node-ini');

http = require('request');

db = require('./db');

docker = require('./docker');

utils = require('./utils');

module.exports = function(options) {
  return new Repos(options);
};

Repos = (function() {
  function Repos(options1) {
    var base, base1;
    this.options = options1 != null ? options1 : {};
    if ((base = this.options).directory == null) {
      base.directory = './public';
    }
    this.options.directory = path.resolve(process.cwd(), this.options.directory);
    if ((base1 = this.options).log == null) {
      base1.log = true;
    }
    this.db = db(this.options.directory);
    this.docker = docker(this.options.debug);
  }

  Repos.prototype.list = function(repos, obj, callback) {
    if (arguments.length === 2) {
      callback = obj;
      obj = false;
    }
    return this.db.get((function(_this) {
      return function(err, config) {
        if (err) {
          return callback(err);
        }
        return fs.readdir(_this.options.directory, function(err, dirs) {
          var dir, i, len, names, ref;
          if (err) {
            return callback(err);
          }
          if (repos != null ? repos.length : void 0) {
            names = repos;
          } else {
            names = ['*'];
          }
          names.push('!config.json');
          dirs = multimatch(dirs, names);
          repos = {};
          for (i = 0, len = dirs.length; i < len; i++) {
            dir = dirs[i];
            repos[dir] = {
              name: dir,
              port: (ref = config.repos[dir]) != null ? ref.port : void 0
            };
          }
          return utils.docker_ps(true, function(err, infos) {
            var _, name, repo;
            if (err) {
              return callback(err);
            }
            for (name in repos) {
              repo = repos[name];
              repo.docker = infos[name] || {};
            }
            if (!obj) {
              repos = (function() {
                var results;
                results = [];
                for (_ in repos) {
                  repo = repos[_];
                  results.push(repo);
                }
                return results;
              })();
            }
            return callback(null, repos);
          });
        });
      };
    })(this));
  };

  Repos.prototype.setPort = function(name, port, callback) {
    return this.db.get((function(_this) {
      return function(err, config) {
        var changed, k, ports_used, v;
        if (err) {
          return err;
        }
        if (config.repos[name] == null) {
          config.repos[name] = {};
          changed = true;
        }
        if (port == null) {
          ports_used = (function() {
            var ref, results;
            ref = config.repos;
            results = [];
            for (k in ref) {
              v = ref[k];
              results.push(v.port);
            }
            return results;
          })();
          port = config.port_inc;
          while (indexOf.call(ports_used, port) >= 0) {
            port++;
          }
          config.repos[name].port = port;
          changed = true;
        } else if (config.repos[name].port !== port) {
          config.repos[name].port = port;
          changed = true;
        }
        if (!changed) {
          return callback();
        }
        return _this.db.set(config, callback);
      };
    })(this));
  };

  Repos.prototype.sync = function(repos, callback) {
    if ((typeof urls !== "undefined" && urls !== null) && repos.length !== urls.length) {
      return Error("repos number (" + repos.length + ") and urls number (" + (typeof urls !== "undefined" && urls !== null ? urls.length : void 0) + ") don't match");
    }
    if ((typeof ports !== "undefined" && ports !== null) && repos.length !== ports.length) {
      return Error("repos number (" + repos.length + ") and ports number (" + (typeof ports !== "undefined" && ports !== null ? ports.length : void 0) + ") don't match");
    }
    return each(repos).parallel(true).run((function(_this) {
      return function(repo, next) {
        var do_end, do_init, ports, repopath;
        ports = [];
        repopath = _this.options.directory + "/" + repo.name;
        do_init = function() {
          return fs.exists(repopath + "/init", function(exists) {
            if (exists) {
              return do_end();
            }
            if (repo.url == null) {
              return Error('Cannot create repo without remote repo url');
            }
            return http({
              url: repo.url
            }, function(err, response, body) {
              if (err) {
                return callback(err);
              }
              return fs.mkdir(repopath, function(err) {
                if (err && err.code !== 'EEXIST') {
                  return callback(err);
                }
                return fs.writeFile(repopath + "/repo", body, function(err) {
                  if (err) {
                    return callback(err);
                  }
                  return ini.parse(repopath + "/repo", function(err, inidata) {
                    var data;
                    if (err) {
                      return callback(err);
                    }
                    data = utils.build_assets(repo, inidata);
                    return fs.writeFile(repopath + "/init", data, function(err) {
                      if (err) {
                        return callback(err);
                      }
                      return fs.chmod(repopath + "/init", 0x1ed, function(err) {
                        if (err) {
                          return callback(err);
                        }
                        return do_end();
                      });
                    });
                  });
                });
              });
            });
          });
        };
        do_end = function() {
          return _this.setPort(repo.name, repo.port, function(err) {
            if (err) {
              return next(err);
            }
            return _this.docker.sync(repopath, function(err, stdout, stderr) {
              return next(err);
            });
          });
        };
        return do_init();
      };
    })(this)).then(callback);
  };

  Repos.prototype.start = function(repos, callback) {
    return this.list(repos.map(function(r) {
      return r.name;
    }), true, (function(_this) {
      return function(err, registered_repos) {
        var i, len, repo;
        if (err) {
          return callback(err);
        }
        for (i = 0, len = repos.length; i < len; i++) {
          repo = repos[i];
          if (repo.port != null) {
            registered_repos[repo.name].port = repo.port;
          }
        }
        return each(registered_repos).parallel(true).run(function(repo, next) {
          var ref;
          if (!repo.docker.names) {
            return _this.docker.run(repo, _this.options.directory, function(err) {
              return next(err);
            });
          } else if (/^Up/.test(repo.docker.status)) {
            if (("" + repo.port) === ((ref = /([\d]+)\->80/.exec(repo.docker.ports)) != null ? ref[1] : void 0)) {
              return next();
            }
            return _this.docker.stop(repo.name, function(err) {
              if (err) {
                return next(err);
              }
              return _this.docker.rm(repo.name, function(err) {
                if (err) {
                  return next(err);
                }
                return _this.docker.run(repo, _this.options.directory, function(err) {
                  return next(err);
                });
              });
            });
          } else {
            return _this.docker.start(repo.name, function(err) {
              return next(err);
            });
          }
        }).then(function(err) {
          return callback(err);
        });
      };
    })(this));
  };

  Repos.prototype.stop = function(repos, callback) {
    return this.list(repos, true, (function(_this) {
      return function(err, repos) {
        if (err) {
          return callback(err);
        }
        return each(repos).run(function(repo, next) {
          var ref;
          if (!/^Up/.test((ref = repo.docker) != null ? ref.status : void 0)) {
            return next();
          }
          return _this.docker.stop(repo.name, next);
        }).then(callback);
      };
    })(this));
  };

  Repos.prototype.remove = function(repos, callback) {
    return each(repos).parallel(true).run((function(_this) {
      return function(repo, next) {
        return _this.docker.rm(repo, function(err) {
          if (err) {
            return next(err);
          }
          if (!_this.options.purge) {
            return next();
          }
          return rmr.remove(_this.options.directory + "/" + repo, next);
        });
      };
    })(this)).then(callback);
  };

  return Repos;

})();
