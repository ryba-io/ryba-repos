// Generated by CoffeeScript 1.9.0
var arg, argTab, buildAssetsFiles, config, count, del, dirpath, e, each, exec, fs, http, i, ini, list, multimatch, parameters, params, path, rm, setPort, start, stop, sync, syncRepo, url, util, _dockerExec, _i, _len,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

parameters = require('parameters');

path = require('path');

rm = require('remove');

multimatch = require('multimatch');

exec = require('child_process').exec;

each = require('each');

url = require('url');

ini = require('node-ini');

http = require('request');

util = require('util');

dirpath = path.normalize((path.dirname(process.argv[1])) + "/../public");

try {
  config = require(dirpath + "/config");
} catch (_error) {
  e = _error;
  console.log(e);
  config = {
    next_port: 10180
  };
  fs.writeFileSync(dirpath + "/config.json", JSON.stringify(config, null, 2));
}

list = function(repos) {
  var dir, file, _i, _len, _results;
  if (repos != null) {
    dir = multimatch(fs.readdirSync(dirpath), repos);
  } else {
    dir = fs.readdirSync(dirpath);
  }
  _results = [];
  for (_i = 0, _len = dir.length; _i < _len; _i++) {
    file = dir[_i];
    _results.push(console.log(file));
  }
  return _results;
};

setPort = function(repo, port) {
  if (port != null) {
    config[repo] = port;
  } else {
    config[repo] = config.next_port;
    config.next_port++;
  }
  fs.writeFileSync(dirpath + "/config.json", JSON.stringify(config, null, 2));
  return port;
};

buildAssetsFiles = function(repo, u, config) {
  var buf, repopath, url_name, url_path;
  url_path = url.parse(u).pathname;
  url_name = url_path.split('/');
  url_name = url_name[url_name.length - 1];
  repopath = dirpath + "/" + repo;
  fs.mkdirSync(repopath + "/assets");
  buf = '#!/bin/bash\n';
  buf += 'set -e\n\n';
  buf += 'yum clean expire-cache\n';
  buf += "wget -nv " + u + " -O /etc/yum.repos.d/" + url_name + "\n";
  buf += 'yum update -y\n';
  Object.keys(config).forEach(function(element, key, _array) {
    path = url.parse(config[element].baseurl).pathname;
    buf += "\n# [" + element + "]\n";
    buf += "mkdir -p /var/ryba" + path + "\n";
    buf += "reposync -p /var/ryba" + path + " --repoid=" + element + "\n";
    return buf += "createrepo /var/ryba" + path + "\n";
  });
  fs.writeFileSync(repopath + "/assets/init", buf);
  return fs.chmodSync(repopath + "/assets/init", 0x1ed);
};

syncRepo = function(repo, u, port) {
  var repopath;
  repopath = dirpath + "/" + repo;
  return fs.exists(repopath, function(exists) {
    var do_end, options;
    do_end = function() {
      return exec("docker run -v " + repopath + "/assets/:/app/ -v " + repopath + ":/var/ryba --rm=true --entrypoint /app/init ryba_repos/syncer", function(r_err, r_stdout, r_stderr) {
        if (r_err) {
          return console.log(r_stderr);
        }
      });
    };
    if (exists) {
      return do_end();
    } else {
      options = {
        url: u
      };
      return http(options, function(err, response, body) {
        var inifile;
        inifile = ini.parse(body);
        return fs.mkdir(repopath, function() {
          buildAssetsFiles(repo, u, inifile);
          return do_end();
        });
      });
    }
  });
};

sync = function(repos, urls, ports) {
  if (repos.length !== (urls != null ? urls.length : void 0)) {
    console.log("targetted repos number (" + repos.length + ") and/or urls number (" + (urls != null ? urls.length : void 0) + ") and/or ports number (" + (ports != null ? ports.length : void 0) + ") don't match, exiting...");
    process.exit(22);
  }
  return each(repos).parallel(true).on('item', function(repo, index, next) {
    return syncRepo(repo, urls != null ? urls[index] : void 0, ports != null ? ports[index] : void 0);
  }).on('both', function(err) {
    if (err) {
      return console.log('Finished with errors :', err.message);
    } else {
      return console.log('Finished successfully !');
    }
  });
};

_dockerExec = function(repos, action, port) {
  console.log(action + " " + repos + ":");
  return each(repos).parallel(true).on('item', function(repo, next) {
    var do_end;
    do_end = function() {
      return exec("docker " + action + " " + repo, function(err, stdout, stderr) {
        return console.log("[" + repo + "]: " + stderr);
      });
    };
    if (action === 'start') {
      if ((config[repo] == null) || (port != null)) {
        setPort(repo, port);
        return exec("docker run --name=repo_" + repo + " -d -v " + dirpath + "/" + repo + ":/usr/local/apache2/htdocs/ -p " + config[repo] + ":80 httpd", function(err, stdout, stderr) {
          if (err) {
            return console.log(stderr);
          }
        });
      } else {
        return do_end();
      }
    } else {
      return do_end();
    }
  }).on('both', function(err) {
    if (err) {
      return console.log('#{action} finished with errors');
    } else {
      return console.log('#{action} finished successfully !');
    }
  });
};

start = function(repos) {
  var i, repo, _i, _len, _results;
  if (repos != null) {
    _results = [];
    for (i = _i = 0, _len = repos.length; _i < _len; i = ++_i) {
      repo = repos[i];
      repos[i] = "repo_" + repo;
      _results.push(_dockerExec(repo, 'start'));
    }
    return _results;
  } else {
    return exec("docker ps -a | grep -oh 'repo_\\S\\+'", function(err, stdout, stderr) {
      if (err) {
        return console.log("Impossible to list repo docker containers: " + stderr);
      } else {
        repos = stdout.split('\n');
        repos.pop();
        return _dockerExec(repos, 'start');
      }
    });
  }
};

stop = function(repos) {
  var i, repo, _i, _len;
  if (repos != null) {
    for (i = _i = 0, _len = repos.length; _i < _len; i = ++_i) {
      repo = repos[i];
      repos[i] = "repo_" + repo;
    }
    return _dockerExec(repos, 'stop');
  } else {
    return exec("docker ps | grep -oh 'repo_\\S\\+'", function(err, stdout, stderr) {
      if (err) {
        return console.log("Impossible to list running repo docker containers: " + stderr);
      } else {
        repos = stdout.split('\n');
        repos.pop();
        return _dockerExec(repos, 'stop');
      }
    });
  }
};

del = function(repos) {
  return each(repos).parallel(true).on('item', function(repo, next) {
    exec("docker rm repo_" + repo, function(err, stdout, stderr) {
      if (err != null) {
        return console.log("[" + repo + "] " + stderr);
      }
    });
    return rm.removeSync(dirpath + "/" + repo);
  }).on('both', function(b_err) {
    if (b_err) {
      return console.log("Finished with ERRORS");
    } else {
      return console.log('Finished successfully!');
    }
  });
};

params = parameters({
  name: 'repos',
  description: 'Install and sync RHEL/CentOS repositories',
  commands: [
    {
      name: 'list',
      description: 'list all the installed repositories',
      options: [
        {
          name: 'repo',
          type: 'array',
          shortcut: 'r',
          description: 'filter'
        }
      ]
    }, {
      name: 'sync',
      description: 'initialize local repo with Docker container',
      options: [
        {
          name: 'repo',
          type: 'array',
          shortcut: 'r',
          required: true,
          description: 'repo(s) to initialize'
        }, {
          name: 'url',
          type: 'array',
          shortcut: 'u',
          required: true,
          description: 'the url(s) of the repo(s)'
        }, {
          name: 'port',
          shortcut: 'p',
          required: false,
          description: 'force port value'
        }
      ]
    }, {
      name: 'start',
      description: 'Start Repo server(s) with Docker without synchronizing repo',
      options: [
        {
          name: 'repo',
          type: 'array',
          shortcut: 'r',
          description: 'the repo(s) to start. All by default'
        }
      ]
    }, {
      name: 'stop',
      description: 'Stop Repo server(s) with Docker',
      options: [
        {
          name: 'repo',
          type: 'array',
          shortcut: 'r',
          description: 'the repo(s) to stop. All by default'
        }
      ]
    }, {
      name: 'rm',
      description: 'Delete a repo',
      options: [
        {
          name: 'repo',
          shortcut: 'r',
          type: 'array',
          required: true,
          description: 'the repo to delete'
        }
      ]
    }
  ]
});

argTab = process.argv.slice(2, process.argv.length);

if (argTab.length > 1 && __indexOf.call(argTab, '-r') < 0) {
  count = 0;
  for (i = _i = 0, _len = argTab.length; _i < _len; i = ++_i) {
    arg = argTab[i];
    if ('-' === arg.charAt(0)) {
      count = 0;
    } else {
      count++;
      if (count === 2) {
        argTab.splice(i, 0, '-r');
        break;
      }
    }
  }
}

arg = params.parse(argTab);

if (arg.command === 'help') {
  console.log(params.help(arg.name));
}

switch (arg.command) {
  case 'list':
    list(arg.repo);
    break;
  case 'sync':
    sync(arg.repo, arg.url, arg.port);
    break;
  case 'start':
    start(arg.repo);
    break;
  case 'stop':
    stop(arg.repo);
    break;
  case 'rm':
    del(arg.repo);
}
