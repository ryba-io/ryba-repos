// Generated by CoffeeScript 1.8.0
var arg, argTab, buildAssetsFiles, config, count, del, dirpath, dockerExec, dockerRun, e, each, exec, fs, http, i, ini, list, multimatch, parameters, params, path, printError, rm, setPort, start, stop, sync, syncRepo, url, util, _i, _len,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

parameters = require('parameters');

path = require('path');

rm = require('remove');

multimatch = require('multimatch');

exec = require('child_process').exec;

each = require('each');

url = require('url');

ini = require('node-ini');

http = require('request');

util = require('util');

printError = function(err) {
  if (err != null) {
    return console.log(err);
  }
};

dirpath = path.normalize("" + (path.dirname(process.argv[1])) + "/../public");

try {
  config = require("" + dirpath + "/config");
} catch (_error) {
  e = _error;
  console.log(e);
  config = {
    next_port: 10180
  };
  fs.writeFile("" + dirpath + "/config.json", JSON.stringify(config, null, 2));
}

list = function(repos, next) {
  return fs.readdir(dirpath, function(err, dir) {
    if (repos == null) {
      repos = ['*'];
    }
    repos.push('!config.json');
    dir = multimatch(dir, repos);
    return next(err, dir);
  });
};

setPort = function(repo, port) {
  if (port != null) {
    config[repo] = port;
  } else {
    config[repo] = config.next_port;
    config.next_port++;
  }
  fs.writeFile("" + dirpath + "/config.json", JSON.stringify(config, null, 2));
  return port;
};

buildAssetsFiles = function(repo, u, config, next) {
  var buf, repopath, url_name, url_path;
  url_path = url.parse(u).pathname;
  url_name = url_path.split('/');
  url_name = url_name[url_name.length - 1];
  repopath = "" + dirpath + "/" + repo;
  buf = '#!/bin/bash\n';
  buf += 'set -e\n\n';
  buf += 'yum clean expire-cache\n';
  buf += "wget -nv " + u + " -O /etc/yum.repos.d/" + url_name + "\n";
  buf += 'yum update -y\n';
  Object.keys(config).forEach(function(element, key, _array) {
    path = url.parse(config[element].baseurl).pathname;
    buf += "\n# [" + element + "]\n";
    buf += "mkdir -p /var/ryba" + path + "\n";
    buf += "reposync -p /var/ryba" + path + " --repoid=" + element + "\n";
    return buf += "createrepo /var/ryba" + path + "\n";
  });
  return fs.writeFile("" + repopath + "/init", buf, function() {
    return fs.chmod("" + repopath + "/init", next);
  });
};

syncRepo = function(repo, u, port) {
  var repopath;
  repopath = "" + dirpath + "/" + repo;
  return fs.exists("" + repopath + "/init", function(exists) {
    var do_end, options;
    do_end = function() {
      return exec("docker run -v " + repopath + ":/var/ryba --rm=true ryba_repos/syncer", function(r_err, r_stdout, r_stderr) {
        if (r_err) {
          console.log(r_stderr);
        }
        return dockerRun(repo, port);
      });
    };
    if (exists && (u == null)) {
      return do_end();
    } else {
      if (u == null) {
        return Error('Cannot create repo without remote repo url');
      }
      options = {
        url: u
      };
      return http(options, function(err, response, body) {
        return ini.parse(body, function(err, inidata) {
          return fs.mkdir(repopath, function() {
            return buildAssetsFiles(repo, u, inidata, do_end);
          });
        });
      });
    }
  });
};

sync = function(repos, urls, ports) {
  if ((urls != null) && repos.length !== urls.length) {
    return Error("repos number (" + repos.length + ") and urls number (" + (urls != null ? urls.length : void 0) + ") don't match");
  }
  if ((ports != null) && repos.length !== ports.length) {
    return Error("repos number (" + repos.length + ") and ports number (" + (ports != null ? ports.length : void 0) + ") don't match");
  }
  return each(repos).parallel(true).on('item', function(repo, index, next) {
    return syncRepo(repo, urls != null ? urls[index] : void 0, ports != null ? ports[index] : void 0);
  }).on('both', function(err) {
    if (err) {
      return console.log('Finished with errors :', err.message);
    } else {
      return console.log('Finished successfully !');
    }
  });
};

dockerExec = function(action, repo, callback) {
  console.log(action, repo);
  return exec("docker " + action + " repo_" + repo, callback);
};

dockerRun = function(repo, port, callback) {
  console.log("run new container: " + repo);
  setPort(repo, port);
  return exec("docker run --name=repo_" + repo + " -d -v " + dirpath + "/" + repo + ":/usr/local/apache2/htdocs/ -p " + port + ":80 httpd", callback);
};

start = function(repos, ports) {
  var startEach;
  startEach = function(r) {
    return each(r).parallel(true).on('item', function(repo, index, next) {
      var port;
      if (ports != null ? ports[index] : void 0) {
        port = parseInt(ports[index]);
        if (config[repo] != null) {
          if (config[repo] !== port) {
            return dockerExec('stop', repo, function(err) {
              return dockerExec('rm', repo, function(err) {
                return dockerRun(repo, port, printError);
              });
            });
          } else {
            return dockerExec('start', repo, printError);
          }
        } else {
          return dockerRun(repo, port, printError);
        }
      } else {
        return dockerExec('start', repo, printError);
      }
    }).on('both', function(err) {
      if (err) {
        return console.log('start finished with errors');
      } else {
        return console.log("start finished successfully !");
      }
    });
  };
  if (repos != null) {
    if ((ports != null) && repos.length !== ports.length) {
      return Error("wrong arguments, please ignore ports or set it for each repo");
    }
    return startEach(repos);
  } else {
    return list(repos, function(err, repos) {
      if (err) {
        return console.log("Impossible to list repo docker containers: " + err);
      } else {
        return startEach(repos);
      }
    });
  }
};

stop = function(repos) {
  var stopEach;
  stopEach = function(r) {
    return each(r).parallel(true).on('item', function(repo, index, next) {
      return dockerExec('stop', repo);
    }).on('both', function(err) {
      if (err) {
        return console.log('Finished with ERRORS');
      } else {
        return console.log("stop finished successfully !");
      }
    });
  };
  if (repos != null) {
    return stopEach(repos);
  } else {
    return exec("docker ps | grep -oh 'repo_\\S\\+'", function(err, stdout, stderr) {
      if (err) {
        return console.log("Impossible to list running repo docker containers: " + stderr);
      } else {
        repos = stdout.split('\n');
        repos.pop();
        return stopEach(repos);
      }
    });
  }
};

del = function(repos) {
  return each(repos).parallel(true).on('item', function(repo, next) {
    return dockerExec('rm', repo, function() {
      return rm.remove("" + dirpath + "/" + repo);
    });
  }).on('both', function(err) {
    if (err) {
      return console.log("Finished with ERRORS");
    } else {
      return console.log('Finished successfully!');
    }
  });
};

params = parameters({
  name: 'repos',
  description: 'Install and sync RHEL/CentOS repositories',
  commands: [
    {
      name: 'list',
      description: 'list all the installed repositories',
      options: [
        {
          name: 'repo',
          type: 'array',
          shortcut: 'r',
          description: 'repo name filter(s)'
        }
      ]
    }, {
      name: 'sync',
      description: 'initialize local repo with Docker container',
      options: [
        {
          name: 'repo',
          type: 'array',
          shortcut: 'r',
          required: true,
          description: 'repo(s) to initialize'
        }, {
          name: 'url',
          type: 'array',
          shortcut: 'u',
          required: false,
          description: 'the url(s) of the repo(s)'
        }, {
          name: 'port',
          shortcut: 'p',
          type: 'array',
          required: false,
          description: 'force port value'
        }
      ]
    }, {
      name: 'start',
      description: 'Start Repo server(s) with Docker',
      options: [
        {
          name: 'repo',
          type: 'array',
          shortcut: 'r',
          description: 'the repo(s) to start. All by default'
        }, {
          name: 'port',
          shortcut: 'p',
          type: 'array',
          description: 'force port value'
        }
      ]
    }, {
      name: 'stop',
      description: 'Stop Repo server(s) with Docker',
      options: [
        {
          name: 'repo',
          type: 'array',
          shortcut: 'r',
          description: 'the repo(s) to stop. All by default'
        }
      ]
    }, {
      name: 'rm',
      description: 'Delete a repo',
      options: [
        {
          name: 'repo',
          shortcut: 'r',
          type: 'array',
          required: true,
          description: 'the repo(s) to delete'
        }
      ]
    }
  ]
});

argTab = process.argv.slice(2, process.argv.length);

if (argTab.length > 1 && __indexOf.call(argTab, '-r') < 0) {
  count = 0;
  for (i = _i = 0, _len = argTab.length; _i < _len; i = ++_i) {
    arg = argTab[i];
    if ('-' === arg.charAt(0)) {
      count = 0;
    } else {
      count++;
      if (count === 2) {
        argTab.splice(i, 0, '-r');
        break;
      }
    }
  }
}

arg = params.parse(argTab);

switch (arg.command) {
  case 'help':
    console.log(params.help(arg.name));
    break;
  case 'list':
    list(arg.repo, function(err, dir) {
      var file, _j, _len1, _results;
      _results = [];
      for (_j = 0, _len1 = dir.length; _j < _len1; _j++) {
        file = dir[_j];
        _results.push(console.log(file));
      }
      return _results;
    });
    break;
  case 'sync':
    sync(arg.repo, arg.url, arg.port);
    break;
  case 'start':
    start(arg.repo, arg.port);
    break;
  case 'stop':
    stop(arg.repo);
    break;
  case 'rm':
    del(arg.repo);
}
