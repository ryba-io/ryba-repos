// Generated by CoffeeScript 1.9.1
var Repos, each, exec, fs, http, ini, multimatch, path, rmr, url, utils;

fs = require('fs');

path = require('path');

rmr = require('remove');

multimatch = require('multimatch');

exec = require('child_process').exec;

each = require('each');

url = require('url');

ini = require('node-ini');

http = require('request');

utils = require('./utils');

module.exports = function(options) {
  return new Repos(options);
};

Repos = (function() {
  function Repos(options1) {
    var base, base1;
    this.options = options1 != null ? options1 : {};
    if ((base = this.options).directory == null) {
      base.directory = './public';
    }
    this.options.directory = path.resolve(process.cwd(), this.options.directory);
    if ((base1 = this.options).log == null) {
      base1.log = true;
    }
  }

  Repos.prototype.list = function(repos, obj, callback) {
    if (arguments.length === 2) {
      callback = obj;
      obj = false;
    }
    return fs.readFile(this.options.directory + "/config.json", 'utf8', (function(_this) {
      return function(err, config) {
        if (err) {
          return callback(err);
        }
        try {
          config = JSON.parse(config);
        } catch (_error) {
          err = _error;
          return callback(err);
        }
        return fs.readdir(_this.options.directory, function(err, dirs) {
          var dir, i, len, names, ref;
          if (err) {
            return callback(err);
          }
          if (repos != null ? repos.length : void 0) {
            names = repos;
          } else {
            names = ['*'];
          }
          names.push('!config.json');
          dirs = multimatch(dirs, names);
          repos = {};
          for (i = 0, len = dirs.length; i < len; i++) {
            dir = dirs[i];
            repos[dir] = {
              name: dir,
              port: (ref = config.repos[dir]) != null ? ref.port : void 0
            };
          }
          return utils.docker_ps(true, function(err, infos) {
            var _, name, repo;
            if (err) {
              return callback(err);
            }
            for (name in repos) {
              repo = repos[name];
              repo.docker = infos[name] || {};
            }
            if (!obj) {
              repos = (function() {
                var results;
                results = [];
                for (_ in repos) {
                  repo = repos[_];
                  results.push(repo);
                }
                return results;
              })();
            }
            return callback(null, repos);
          });
        });
      };
    })(this));
  };

  Repos.prototype.setPort = function(repo, callback) {
    return fs.readFile(this.options.directory + "/config.json", 'utf8', (function(_this) {
      return function(err, config) {
        var base, changed, name1, ref;
        if (err && err.code !== 'ENOENT') {
          return callback(err);
        }
        config = err ? {} : JSON.parse(config);
        if (config.port_inc == null) {
          config.port_inc = 10180;
        }
        if (repo.port == null) {
          repo.port = config.port_inc++;
          changed = true;
        } else if (((ref = config.repos[repo.name]) != null ? ref.port : void 0) !== (repo.port != null)) {
          if ((base = config.repos)[name1 = repo.name] == null) {
            base[name1] = {};
          }
          config.repos[repo.name].port = repo.port;
          changed = true;
        }
        if (!changed) {
          return callback();
        }
        return fs.writeFile(_this.options.directory + "/config.json", JSON.stringify(config, null, 2), function(err) {
          return callback(err);
        });
      };
    })(this));
  };

  Repos.prototype.sync = function(repos, callback) {
    if ((typeof urls !== "undefined" && urls !== null) && repos.length !== urls.length) {
      return Error("repos number (" + repos.length + ") and urls number (" + (typeof urls !== "undefined" && urls !== null ? urls.length : void 0) + ") don't match");
    }
    if ((typeof ports !== "undefined" && ports !== null) && repos.length !== ports.length) {
      return Error("repos number (" + repos.length + ") and ports number (" + (typeof ports !== "undefined" && ports !== null ? ports.length : void 0) + ") don't match");
    }
    return each(repos).parallel(true).run((function(_this) {
      return function(repo, next) {
        var do_end, do_init, ports, repopath;
        ports = [];
        repopath = _this.options.directory + "/" + repo.name;
        do_init = function() {
          return fs.exists(repopath + "/init", function(exists) {
            if (exists) {
              return do_end();
            }
            if (repo.url == null) {
              return Error('Cannot create repo without remote repo url');
            }
            return http({
              url: repo.url
            }, function(err, response, body) {
              if (err) {
                return callback(err);
              }
              return fs.mkdir(repopath, function(err) {
                if (err && err.code !== 'EEXIST') {
                  return callback(err);
                }
                return fs.writeFile(repopath + "/repo", body, function(err) {
                  if (err) {
                    return callback(err);
                  }
                  return ini.parse(repopath + "/repo", function(err, inidata) {
                    var data;
                    if (err) {
                      return callback(err);
                    }
                    data = utils.build_assets(repo.name, repo.url, inidata);
                    return fs.writeFile(repopath + "/init", data, function(err) {
                      if (err) {
                        return callback(err);
                      }
                      return fs.chmod(repopath + "/init", 0x1ed, function(err) {
                        if (err) {
                          return callback(err);
                        }
                        return do_end();
                      });
                    });
                  });
                });
              });
            });
          });
        };
        do_end = function() {
          return exec("if command -v boot2docker; then boot2docker up && $(boot2docker shellinit); fi\ndocker run -v " + repopath + ":/var/ryba --rm=true ryba_repos/syncer", function(err, stdout, stderr) {
            return next(err);
          });
        };
        return do_init();
      };
    })(this)).then(callback);
  };

  Repos.prototype.start = function(repos, callback) {
    return this.list(repos.map(function(r) {
      return r.name;
    }), true, (function(_this) {
      return function(err, registered_repos) {
        var i, len, repo;
        if (err) {
          return callback(err);
        }
        for (i = 0, len = repos.length; i < len; i++) {
          repo = repos[i];
          if (repo.port != null) {
            registered_repos[repo.name].port = repo.port;
          }
        }
        return each(registered_repos).parallel(true).run(function(repo, next) {
          var ref;
          if (!repo.docker.names) {
            return utils.docker_run(repo, _this.options.directory, function(err) {
              return next(err);
            });
          } else if (/^Up/.test(repo.docker.status)) {
            if (("" + repo.port) === ((ref = /([\d]+)\->80/.exec(repo.docker.ports)) != null ? ref[1] : void 0)) {
              return next();
            }
            return utils.docker_exec(repo.name, 'stop', function(err) {
              if (err) {
                return next(err);
              }
              return utils.docker_exec(repo.name, 'rm', function(err) {
                if (err) {
                  return next(err);
                }
                return utils.docker_run(repo, _this.options.directory, function(err) {
                  if (err) {
                    return next(err);
                  }
                  return setPort(repo, function(err) {
                    return next(err);
                  });
                });
              });
            });
          } else {
            return utils.docker_exec(repo.name, 'start', function(err) {
              return next(err);
            });
          }
        }).then(function(err) {
          return callback(err);
        });
      };
    })(this));
  };

  Repos.prototype.stop = function(repos, callback) {
    return this.list(repos, true, (function(_this) {
      return function(err, repos) {
        if (err) {
          return callback(err);
        }
        return each(repos).run(function(repo, next) {
          var ref;
          if (!/^Up/.test((ref = repo.docker) != null ? ref.status : void 0)) {
            return next();
          }
          return utils.docker_exec(repo.name, 'stop', next);
        }).then(callback);
      };
    })(this));
  };

  Repos.prototype.remove = function(repos, callback) {
    return each(repos).parallel(true).run((function(_this) {
      return function(repo, next) {
        return utils.docker_exec(repo, 'rm', function(err) {
          if (err) {
            return next(err);
          }
          return rmr.remove(_this.options.directory + "/" + repo, next);
        });
      };
    })(this)).then(callback);
  };

  return Repos;

})();
