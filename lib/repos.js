// Generated by CoffeeScript 1.9.0
var dirpath, each, exec, fs, http, ini, multimatch, path, printError, rmr, setPort, url, utils;

fs = require('fs');

path = require('path');

rmr = require('remove');

multimatch = require('multimatch');

exec = require('child_process').exec;

each = require('each');

url = require('url');

ini = require('node-ini');

http = require('request');

utils = require('./utils');

printError = function(err) {
  if (err != null) {
    return console.log(err);
  }
};

dirpath = path.normalize((path.dirname(process.argv[1])) + "/../public");

exports.list = function(repos, obj, callback) {
  if (arguments.length === 2) {
    callback = obj;
    obj = false;
  }
  return fs.readFile(dirpath + "/config.json", 'utf8', function(err, config) {
    if (err) {
      return callback(err);
    }
    try {
      config = JSON.parse(config);
    } catch (_error) {
      err = _error;
      return callback(err);
    }
    return fs.readdir(dirpath, function(err, dirs) {
      var dir, names, _i, _len, _ref;
      if (err) {
        return callback(err);
      }
      if (repos != null ? repos.length : void 0) {
        names = repos;
      } else {
        names = ['*'];
      }
      names.push('!config.json');
      dirs = multimatch(dirs, names);
      repos = {};
      for (_i = 0, _len = dirs.length; _i < _len; _i++) {
        dir = dirs[_i];
        repos[dir] = {
          name: dir,
          port: (_ref = config[dir]) != null ? _ref.port : void 0
        };
      }
      return utils.docker_ps(true, function(err, infos) {
        var name, repo, _;
        if (err) {
          return callback(err);
        }
        for (name in repos) {
          repo = repos[name];
          repo.docker = infos[name] || {};
        }
        if (!obj) {
          repos = (function() {
            var _results;
            _results = [];
            for (_ in repos) {
              repo = repos[_];
              _results.push(repo);
            }
            return _results;
          })();
        }
        return callback(null, repos);
      });
    });
  });
};

setPort = function(repo, callback) {
  return fs.readFile(dirpath + "/config.json", 'utf8', function(err, config) {
    var changed, _name, _ref;
    if (err && err.code !== 'ENOENT') {
      return callback(err);
    }
    config = err ? {} : JSON.parse(config);
    if (config.port_inc == null) {
      config.port_inc = 10180;
    }
    if (repo.port == null) {
      repo.port = config.port_inc++;
      changed = true;
    } else if (((_ref = config[repo.name]) != null ? _ref.port : void 0) !== (repo.port != null)) {
      if (config[_name = repo.name] == null) {
        config[_name] = {};
      }
      config[repo.name].port = repo.port;
      changed = true;
    }
    if (!changed) {
      return callback();
    }
    return fs.writeFile(dirpath + "/config.json", JSON.stringify(config, null, 2), function(err) {
      return callback(err);
    });
  });
};

exports.sync = function(repos, callback) {
  if ((typeof urls !== "undefined" && urls !== null) && repos.length !== urls.length) {
    return Error("repos number (" + repos.length + ") and urls number (" + (typeof urls !== "undefined" && urls !== null ? urls.length : void 0) + ") don't match");
  }
  if ((typeof ports !== "undefined" && ports !== null) && repos.length !== ports.length) {
    return Error("repos number (" + repos.length + ") and ports number (" + (typeof ports !== "undefined" && ports !== null ? ports.length : void 0) + ") don't match");
  }
  return each(repos).parallel(true).on('item', function(repo, next) {
    var do_end, do_init, ports, repopath;
    ports = [];
    repopath = dirpath + "/" + repo.name;
    do_init = function() {
      return fs.exists(repopath + "/init", function(exists) {
        if (exists) {
          return do_end();
        }
        if (repo.url == null) {
          return Error('Cannot create repo without remote repo url');
        }
        return http({
          url: repo.url
        }, function(err, response, body) {
          if (err) {
            return callback(err);
          }
          return fs.mkdir(repopath, function(err) {
            if (err && err.code !== 'EEXIST') {
              return callback(err);
            }
            return fs.writeFile(repopath + "/repo", body, function(err) {
              if (err) {
                return callback(err);
              }
              return ini.parse(repopath + "/repo", function(err, inidata) {
                var data;
                if (err) {
                  return callback(err);
                }
                data = utils.build_assets(repo.name, repo.url, inidata);
                return fs.writeFile(repopath + "/init", data, function(err) {
                  if (err) {
                    return callback(err);
                  }
                  return fs.chmod(repopath + "/init", 0x1ed, function(err) {
                    if (err) {
                      return callback(err);
                    }
                    return do_end();
                  });
                });
              });
            });
          });
        });
      });
    };
    do_end = function() {
      return exec("if command -v boot2docker; then boot2docker up && $(boot2docker shellinit); fi\ndocker run -v " + repopath + ":/var/ryba --rm=true ryba_repos/syncer", function(err, stdout, stderr) {
        return next(err);
      });
    };
    return do_init();
  }).on('both', function(err) {
    if (err) {
      return console.log('Finished with errors :', err.message);
    } else {
      return console.log('Finished successfully !');
    }
  });
};

exports.start = function(repos, callback) {
  return exports.list(repos.map(function(r) {
    return r.name;
  }), true, function(err, registered_repos) {
    var repo, _i, _len;
    if (err) {
      return callback(err);
    }
    for (_i = 0, _len = repos.length; _i < _len; _i++) {
      repo = repos[_i];
      if (repo.port != null) {
        registered_repos[repo.name].port = repo.port;
      }
    }
    return each(registered_repos).parallel(true).on('item', function(repo, next) {
      var _ref;
      if (!repo.docker.names) {
        return utils.docker_run(repo, dirpath, function(err) {
          return next(err);
        });
      } else if (/^Up/.test(repo.docker.status)) {
        if (("" + repo.port) === ((_ref = /([\d]+)\->80/.exec(repo.docker.ports)) != null ? _ref[1] : void 0)) {
          return next();
        }
        return utils.docker_exec(repo.name, 'stop', function(err) {
          if (err) {
            return next(err);
          }
          return utils.docker_exec(repo.name, 'rm', function(err) {
            if (err) {
              return next(err);
            }
            return utils.docker_run(repo, dirpath, function(err) {
              if (err) {
                return next(err);
              }
              return setPort(repo, function(err) {
                return next(err);
              });
            });
          });
        });
      } else {
        return utils.docker_exec(repo.name, 'start', function(err) {
          return next(err);
        });
      }
    }).on('both', function(err) {
      return callback(err);
    });
  });
};

exports.stop = function(repos, callback) {
  return exports.list(repos, true, function(err, repos) {
    if (err) {
      return callback(err);
    }
    return each(repos).run(function(repo, next) {
      var _ref;
      if (!/^Up/.test((_ref = repo.docker) != null ? _ref.status : void 0)) {
        return next();
      }
      return utils.docker_exec(repo.name, 'stop', next);
    }).then(callback);
  });
};

exports.remove = function(repos, callback) {
  console.log('remove ok', repos, callback);
  return each(repos).parallel(true).run(function(repo, next) {
    console.log('remove start');
    return utils.docker_exec(repo, 'rm', function(err) {
      if (err) {
        return next(err);
      }
      return rmr.remove(dirpath + "/" + repo, next);
    });
  }).then(callback);
};
